From 02f44c137df99ed2e89699e49b64c13673b0cd06 Mon Sep 17 00:00:00 2001
From: Yonit Halperin <yhalperi@redhat.com>
Date: Thu, 25 Jul 2013 15:07:43 -0400
Subject: [PATCH 7/8] snd_worker/snd_disconnect_channel: don't call
 snd_channel_put if the channel has already been disconnected

The snd channels has one reference as long as their socket is active.
The playback channel has an additional reference for each frame that is
currently filled by the sound device.
Once the channel is disconnected (the socket has been freed and the
first reference is released) snd_disconnect_channel shouldn't release
a reference again.
---
 server/snd_worker.c | 20 ++++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/server/snd_worker.c b/server/snd_worker.c
index 849f002..3827416 100644
--- a/server/snd_worker.c
+++ b/server/snd_worker.c
@@ -212,21 +212,20 @@ static void snd_disconnect_channel(SndChannel *channel)
 {
     SndWorker *worker;
 
-    if (!channel) {
+    if (!channel || !channel->stream) {
         spice_debug("not connected");
         return;
     }
     spice_debug("%p", channel);
     worker = channel->worker;
-    if (channel->stream) {
-        channel->cleanup(channel);
-        red_channel_client_disconnect(worker->connection->channel_client);
-        core->watch_remove(channel->stream->watch);
-        channel->stream->watch = NULL;
-        reds_stream_free(channel->stream);
-        channel->stream = NULL;
-        spice_marshaller_destroy(channel->send_data.marshaller);
-    }
+    channel->cleanup(channel);
+    red_channel_client_disconnect(worker->connection->channel_client);
+    worker->connection->channel_client = NULL;
+    core->watch_remove(channel->stream->watch);
+    channel->stream->watch = NULL;
+    reds_stream_free(channel->stream);
+    channel->stream = NULL;
+    spice_marshaller_destroy(channel->send_data.marshaller);
     snd_channel_put(channel);
     worker->connection = NULL;
 }
@@ -897,6 +896,7 @@ static SndChannel *__new_channel(SndWorker *worker, int size, uint32_t channel_i
     int tos;
     MainChannelClient *mcc = red_client_get_main(client);
 
+    spice_assert(stream);
     if ((flags = fcntl(stream->socket, F_GETFL)) == -1) {
         spice_printerr("accept failed, %s", strerror(errno));
         goto error1;
-- 
1.8.3.1

